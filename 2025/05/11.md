## 取り組んだ課題一覧

- mosyaReact
    - useReducer
    - リストの更新

## わかったこと

### useReducer

- useRecucerの基本構文
    
    ```jsx
    const [state, dispatch] = useReducer(reducerFunction, initialState);
    ```
    
    - 第一引数にはカスタムHook、第二引数には初期値を入れる
- useReducerを使用することでuseStateを複数定義する必要がなくなる（まとめて書ける）
    
    ```jsx
    import React, { useReducer, useRef, useState } from "react";
    import { createRoot } from "react-dom/client";
    
    import { Dialog } from "./dialog";
    
    export const todoReducer = (state, action) => {
      switch(action.type) {
        case "ADD" :
          const newData = {
            id: Date.now(),
            title: action.title
          }
          return [
            ...state,newData
          ]
        case "REMOVE":
          const filteredData = state.filter((todo)=>todo.id !== action.id)
          return filteredData
        case "UPDATE" :
          return state.map((todo) =>{
            if(todo.id === action.id) {
              return {...todo,title: action.title}
            }else {
              return todo
            }
          }) 
      }
    };
    
    export default function App() {
      const inputRef = useRef(null);
      const [id, setId] = useState(null);
      const [todos, dispatch] = useReducer(todoReducer, []);
      const handleAddTodo = () => {
        const title = inputRef.current.value;
        inputRef.current.value = "";
        dispatch({ type: "ADD", title });
      };
      const handleRemoveTodo = (id) => () => {
        dispatch({ type: "REMOVE", id });
      };
      const handleEditTodo = (id) => () => {
        setId(id);
      };
      const handleCloseDialog = () => {
        setId(null);
      };
      const handleUpdateTodo = (title) => {
        dispatch({ type: "UPDATE", id, title });
      };
      const currentTodo = todos.find((todo) => todo.id === id);
    
      return (
        <div>
          <div className="todo-header"></div>
          <div className="todo-container">
            <div className="todo-input-wrap">
              <input className="todo-input" ref={inputRef} type="text" />
              <button className="todo-add-btn" onClick={handleAddTodo}>
                +
              </button>
            </div>
            <ul className="todo-list">
              {todos.map((todo) => (
                <li key={todo.id}>
                  {todo.title}
                  <div className="todo-list__btn">
                    <button
                      className="todo-remove"
                      onClick={handleRemoveTodo(todo.id)}
                    >
                      削除
                    </button>
                    <button className="todo-edit" onClick={handleEditTodo(todo.id)}>
                      編集
                    </button>
                  </div>
                </li>
              ))}
            </ul>
          </div>
          {!!currentTodo && (
            <Dialog
              defaultTitle={currentTodo.title}
              onClose={handleCloseDialog}
              onUpdate={handleUpdateTodo}
            />
          )}
        </div>
      );
    }
    
    export const root = createRoot(document.getElementById("root"));
    
    root.render(<App />);
    ```
    
    - UseRducerの処理の流れ
        
        ```jsx
        todos  →  dispatch(action)  →  todoReducer(todos, action)  →  新しい todos に更新
        ```
        
        - ```const [todos, dispatch] = useReducer(todoReducer, [])```のtodosと```export const todoReducer = (state, action) => {```のstateは **対応している**
    - JSX内のonClick内で```handleEditTodo(todo.id)```や```onClick={handleAddTodo}```をコールバック関数で書くと関数は呼び出されるが、実行されないため意図した挙動にならない
    - useReducerではdispatchが更新用関数となる
    - Reactはイミュータブルでないといけないためpush等のメソッドは使ってはいけない値を配列に追加する時はスプレッド構文を使用して元の配列をコピーして値を追加しなければならない(```return {...todo,title: action.title}```)

## 次やること

- mosyaReact
    - リストの更新

## 感じたこと

- useReducerの理解は容易では無い。前に勉強したときも詰まった箇所だと思い出した。
- どれだけ複雑でも因数分解（紐の絡まりを解くように）一つ一つ落ち着いて分解すれば、AIなしでも
コードが書けるかもしれないと思った。

## 学習時間

- 9h